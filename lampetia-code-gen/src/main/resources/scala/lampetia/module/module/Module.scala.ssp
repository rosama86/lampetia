#import(lampetia.metamodel.Module)
#import(lampetia.metamodel._)
#import(lampetia.extensions.Strings)
#import(lampetia.cg.extensions.Models)
#import(lampetia.cg.extensions.Scalate)
#import(com.typesafe.config.Config)
#import(Strings._)
#import(Models._)
<%@ val metamodels: Seq[Model] %>
<%@ val module: Module%>
<%@ val config: Config%>

package ${module.basePackage}.module

import lampetia.conf.Configuration
import ${module.basePackage}.format.{${module.modelName}JsonFormat, ${module.modelName}SqlFormat}
import lampetia.sql.dialect.postgresql.{PostgresqlConfiguration, Postgresql}
import ${module.basePackage}.conf.${module.modelName}Configuration
import ${module.basePackage}.model.${module.modelName}Model
<%@val imports: Seq[String] %>
#for (i <- imports)
  import ${i}
#end

trait ${module.modelName}Module {

    object json extends ${module.modelName}JsonFormat

  object sql extends Postgresql with ${module.modelName}Model with ${module.modelName}SqlFormat {
    val schema = configuration.schema

    implicit lazy val context: sql.ConnectionSource = sql.hikari(
      configuration.pgJdbcDataSourceClassName,
      configuration.pgHost,
      configuration.pgPort,
      configuration.pgDatabase,
      configuration.pgUser,
      configuration.pgPassword,
      configuration.pgMaximumPoolSize,
      configuration.pgLeakDetectionThreshold)
  }

  object configuration
    extends Configuration
      with ${module.modelName}Configuration
      with PostgresqlConfiguration {
    def close(): Unit = sql.context.shutdown()
  }
}

object ${module.modelName}Module extends ${module.modelName}Module