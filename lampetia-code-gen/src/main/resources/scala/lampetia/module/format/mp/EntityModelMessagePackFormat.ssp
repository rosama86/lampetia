#import(lampetia.metamodel.Module)
#import(lampetia.metamodel._)
#import(lampetia.extensions.Strings)
#import(lampetia.cg.extensions.Models)
#import(lampetia.cg.extensions.Scalate)
#import(com.typesafe.config.Config)
#import(Strings._)
#import(Models._)
<%@ val metamodels: Seq[Model] %>
<%@ val module: Module%>
<%@ val config: Config%>
<%@ val model: Entity %>

#if (model.hasReferenceModel)
  ${render("CompositeModelMessagePackFormat.ssp", Map("model" -> model.referenceModel))}
#end
  ${render("CompositeModelMessagePackFormat.ssp", Map("model" -> model.dataModel))}

#if (model.hasReferenceModel)
  implicit lazy val consume${model.modelName}: Consume[${model.modelName}] =
    (consume[${model.idModelName}] ~ consume[${model.refModelName}] ~ consume[${model.dataModelName}] ~ consume[Timestamp])(${model.modelName})

  implicit lazy val produce${model.modelName}: Produce[${model.modelName}] =
    a => produce(a.id) andThen produce(a.ref) andThen produce(a.data) andThen produce(a.timestamp)
#else
  implicit lazy val consume${model.modelName}: Consume[${model.modelName}] =
    (consume[${model.idModelName}] ~ consume[${model.dataModelName}] ~ consume[Timestamp])(${model.modelName})

  implicit lazy val produce${model.modelName}: Produce[${model.modelName}] =
    a => produce(a.id) andThen produce(a.data) andThen produce(a.timestamp)
#end

implicit lazy val ${model.modelName.camelCase}MessagePackFormat: BinaryFormat[${model.modelName}] = messagePackFormat[${model.modelName}]
