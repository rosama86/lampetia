#import(lampetia.metamodel.Module)
#import(lampetia.metamodel._)
#import(lampetia.cg.extensions.Models)
#import(lampetia.cg.extensions.Scalate)
#import(com.typesafe.config.Config)
#import(Models._)
<%@ val metamodels: Seq[Model] %>
<%@ val module: Module%>
<%@ val config: Config%>
package ${module.basePackage}.format

import lampetia.codec.{OptionCodecs, PrimitiveCodecs, Codec}
import lampetia.model._
import ${module.basePackage}.model._
import play.api.libs.json.Json
<%@val imports: Seq[String] %>
#for (i <- imports)
  import ${i}
#end

trait ${module.modelName}SqlFormat { self: Codec with PrimitiveCodecs with OptionCodecs =>

#for (model <- metamodels.valueModels)
  <%val name = model.modelName%>
  <%val pType = model.valueProperty.tpe.modelName %>
  implicit lazy val consume${name}: Consume[${name}] = consume[${pType}].fmap(${name})
  implicit lazy val produce${name}: Produce[${name}] = a => produce(a.value)
#end

#for (model <- metamodels.idModels)
  <%val name = model.modelName%>
  implicit lazy val consume${name}: Consume[${name}] = consume[String].fmap(${name})
  implicit lazy val produce${name}: Produce[${name}] = a => produce(a.value)

#end

#for (model <- metamodels.enumModels)
  <%val name = model.modelName%>
  implicit lazy val consume${name}: Consume[${name}] = consume[String].fmap(${name}.apply)
  implicit lazy val produce${name}: Produce[${name}] = a => produce(a.value)

#end

#for (model <- metamodels.entityModels)
  <%
    val name = model.modelName
    val hasId = metamodels.idEntity.contains(model)

    // consume
    val cprefix = "consume["
    val cpostfix = "]"
    val cid = if(hasId) cprefix + model.idModelName + cpostfix else ""
    val cref = if(model.hasReferenceModel) cprefix + model.refModelName + cpostfix else ""
    val cdata = if(model.hasData) cprefix  + model.dataModelName + cpostfix else ""
    val consume = List(cid, cref,cdata).filter(_ != "").mkString(" ~ ")

    // produce
    val pprefix = "produce(a."
    val ppostfix = ")"
    val pid = if(hasId) pprefix + model.id.propertyName + ppostfix else ""
    val pref = if(model.hasReferenceModel) pprefix + "ref" + ppostfix else ""
    val pdata = if(model.hasData) pprefix  + "data" + ppostfix else ""
    val produce = List(pid, pref, pdata).filter(_ != "").mkString(" andThen ")
  %>
  implicit lazy val consume${name}: Consume[${name}] =
    (${consume})(${name})
  implicit lazy val produce${name}: Produce[${name}] =
    a => ${produce}

  <%

    def producer(f:Property => String )(prefix: String, postfix: String)(props: Seq[Property], pp: List[String]): List[String] = props match {
      case Nil  => pp
      case hp :: t =>
        val np: String =  prefix + f(hp) + postfix
        producer(f)(prefix, postfix)(t, pp :+ np)
    }

    val consumeData =  producer(p =>  p.tpe.modelName)(cprefix, cpostfix)(model.dataModel.properties.toList, Nil).mkString(" ~ ")
    val produceData =  producer(p =>  p.propertyName)(pprefix, ppostfix)(model.dataModel.properties.toList, Nil).mkString(" andThen ")

  %>
  #if (model.hasData)
    implicit lazy val consume${model.dataModelName}: Consume[${model.dataModelName}] =
      (${consumeData})(${model.dataModelName})
    implicit lazy val produce${model.dataModelName}: Produce[${model.dataModelName}] =
      a => ${produceData}

  #end

  <%
    val consumeRef =  producer(p =>  p.tpe.modelName)(cprefix, cpostfix)(model.entityRefProperties.toList, Nil).mkString(" ~ ")
    val produceRef =  producer(p =>  p.propertyName)(pprefix, ppostfix)(model.entityRefProperties.toList, Nil).mkString(" andThen ")

  %>
  #if (model.hasReferenceModel)
    implicit lazy val consume${model.refModelName}: Consume[${model.refModelName}] =
      (${consumeRef}).fmap(${model.refModelName})
    implicit lazy val produce${model.refModelName}: Produce[${model.refModelName}] =
      a => ${produceRef}
  #end
#end
}

<!--

handle js value
implicit lazy val consumeProviderResponse: Consume[ProviderResponse] =
consume[String].fmap(Json.parse).fmap(ProviderResponse)
implicit lazy val produceProviderResponse: Produce[ProviderResponse] =
a => produce(Json.stringify(a.json))
-->